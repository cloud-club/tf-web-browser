# 7장 버튼과 링크 처리하기
## 7.1 링크는 어디에 있는가?

- 웹의 핵심은 링크이므로, 브라우저 인터페이스의 가장 중요한 부분은 링크를 클릭하는 것입니다.
- 화면 위 어디에 링크가 있을까?
    - 서식이 있는 텍스트에 대해서 레이아웃 트리안에 기록이 필요함
    - 두 가지 새로운 유형의 레이아웃 객체의 도입 필요: LineLayout, TextLayout
        - BlockLayout은 각 텍스트 줄마다 LineLayout을 자식으로 가짐
        - LineLayout은 해당 줄의 단어마다 TextLayout을 가짐

```jsx
<html>
	<body>
		I am
		<br>
		Dahyeon
	</body>
</html>
```

```jsx
DocumentLayout
	BlockLayout (html element)
			BlockLayout (body element)
				LineLayout
					TextLayout ("I")
					TextLayout ("am")
				LineLayout
					TextLayout ("Dahyeon")
	...
```

- LineLayout의 layout 메서드는 자신의 위치를 계산할 수 있고, desplay_list 필드 대신 각각의 TextLayout이 paint하면 됩니다.
- 단어를 줄에 추가하면, line 필드 대신 TextLayout 객체를 만들어 LineLayout 객체에 추가합니다. 현재 줄은 children 배열의 끝에서 찾을 수 있습니다.
    - 라인의 끝에 도달하면 flush를 호출하여 텍스트 위치를 지정하거나 line 필드를 수행하는 작업을 하지 않고, LineLayout 객체를 새로 만듭니다.
- layout 메서드는 재귀적으로 자식 노드를 호출해서 배치합니다.
    - 줄의 높이를 더해 텍스트 문단의 높이를 계산할 수 있어, 레이아웃 모드에 따라 코드가 달라질 필요가 없습니다.

## 7.2 라인 레이아웃

- 레이아웃을 처리
- 텍스트 레이아웃
    - 폰트 구성 코드를 사용해서 폰트부터 가져옵니다.
    - 단어의 크기와 x의 위치를 계산합니다. 폰트 메트릭을 사용하여 크기를 계산하고 왼쪽에서 오른쪽으로 단어들을 쌓으며 위치를 계산합니다.
- 라인 레이아웃
    - 최대 어센트와 디센트를 기준으로 줄의 기준선을 계산
        - 각 단어의 font 필트를 읽고 각 단어의 y필드에 쓰고 있습니다.
- TextLayout의 layout 메서드 내에서 w.width, higth 뿐만 아니라 Font도 계산해야 하지만, y는 계산하지 않습니다.
    - y의 위치는 LineLayout의 layout 메서드 안에서 계산할 것
- 페인팅으로는, LineLayout은 칠하지 않고 TextLayout은 각각 하나의 DrawText를 생성합니다.

## 7.3 클릭 처리

- 클릭 처리는 특정 이벤트에 이벤트 핸들러를 바인딩하면 됩니다.
- 클릭이 발생한 위치를 알려주는 x와 y 필드가 이벤트 객체로 넘어옵니다. 넘어오는 x와 y값의 좌표계는 브라우저 창을 기준으로 합니다.
- 일반적으로 클릭과 같은 이벤트를 처리하려면, 렌더링 파이프라인을 거꾸로 돌리면 됩니다.
    - 렌더링은 엘리먼트에서 레이아웃 객제로, 페이지 좌표를 거쳐 화면 좌표로 진행됩니다.
    - 클릭은 화면좌표에서 페이지 좌표, 레이아웃 객체, 엘리먼트로 변환하며 진행 (비유)
- 링크는 일반적으로 텍스트 노드이나, 실제 클릭한 URL은 HTML 트리를 거슬러 링크 엘리먼트를 찾아야 한다.
    - 링크를 찾으면 URL을 추출해서 저장하고 로드해야 합니다.

## 7.4 탭 브라우징

- 새 탭으로 링크를 여는 기능
- 탭과 브라우저를 분리
    - Browser 클래스는 윈도우와 캔버스 그리고 이벤트 핸들링과 같은 관련된 메서드들을 가지며, 또한 Tab 객체들과 browser 크롬을 가질 것입니다.
    - 그러나 웹페이지와 같은 메서들은 Tab 클래스에 있을 것입니다.
- 클래스 분리 과정
    - 기존 Browser 클래스 이름을 Tab으로 변경
        - Tab의 scrolldown과 click 메서드는 수정합니다.
            - scrolldown은 인수를 받지 않고, click은 이벤트 객체 대신 x,y 좌표만 받습니다.
    - 새 Browser 클래스 (탭들의 리스트, 어떤 탭이 활성 상태인지). Browser는 윈도우를 소유하고 모든 이벤트를 처리
        - handle_down과 handle_click 메서드는 페이지 관련 정보가 필요합니다. 이런 핸들러는 활성 탭에 이벤트를 전달합니다.

## 7.5 브라우저 크롬

- 브라우저는 웹 페이지 콘텐츠만 표시하는 것이 아니라, 레이블/아이콘/버튼들도 표시합니다.
- 이런 요소를 모아 브라우저 ‘크롬’이라고 합니다. 이 모든 것들은 브라우저가 윈도우에 그립니다.
- 크롬을 지원하려면 브라우저 전체에 대한 정보가 필요하므로, 탭 단위가 아닌 브라우저 레벨에서 처리되어야 합니다.
- 크롬 디자인
    - 상단에는 새 탭 추가를 위한 + 버튼 표시
    - 뒤로 가기 버튼인 < 표시
- 크롬 구현
    - 크롬에 다양한 요소의 크기를 표현할 직사각형을 저장합니다. 새로운 Rect 클래스를 생성합니다.
    - 탭 버튼 주위에 패딩을 추가. 다음 탭은 새 탭의 버튼의 끝에서 패딩을 더한 위치부터 시작.
    - 활성 탭을 식별하도록, 현재 탭에 대해 튀어나온 폴더 모양을 만듭니다.
    - 브라우저 크롬이 항상 페이지의 콘텐츠보다 위에 그려지게, 크롬 뒤에 하얀 직사각형을 그립니다.
    - 배경은 가장 먼저 그려져야 합니다.
    - 높이를 조정합니다.
    - 탭을 클릭하여 탭 사이 전환이 이루어져야 합니다. Browser의 클릭 핸들러에서 브라우저 크롬의 클릭은 Chrome 객체에 위임합니다.

## 7.6 히스토리 탐색

- 페이지를 돌아다니다 보면, 현재 어떤 웹페이지를 보고 있는지 잊기 쉽습니다. 이때 현재 URL을 보여주는 주소창이 큰 도움이 됩니다. 주소창을 만들어봅시다.
- URL바는 뒤로 가기 버튼과 주소 표시줄을 가집니다.
    - 뒤로가기를 하려면, 어떤 페이지를 방문했는지 히스토리를 저장해야 합니다. 히스토리는 새 페이지로 이동할 때마다 점점 커집니다. (리스트 형태)

## 7.7 URL 입력하기

- 대부분의 브라우저는 주소창에 직접 입력해서 새로운 URL을 방문하는 기능을 제공합니다.
    - 먼저 주소 창을 클릭하여 주소창을 ‘포커스’되게 합니다.
    - 전체 주소가 선택되서 사용자가 입력을 시작하면 모든 주소가 삭제됩니다.
    - 타이핑하는 문자들이 주소창 안에 적힙니다.
    - 입력할 때마다 주소창은 업데이트되지만, 브라우저는 아직 새 페이지로 이동하지 않습니다.
- 브라우저가 주소창의 내용을 url 필드과 별도로 저장해야 하고, 주소창이 현재 입력 중인지 여부를 알 수 있는 상태가 있어야 합니다. (address_bar, focus)
    - 주소창을 선택하면 콘텐츠가 지워지도록 함. (텍스트 선택 기능 생략)
    - 사용자 주소창 타이핑을 보여주기 위한 커서
    - 주소창이 포커스 되었을 때 URL 입력을 지원하도록 Key 바인딩 (handle_key)
        - 모든 키를 누를 때마다 실행되므로, 문자를 입력하지 않았거나 문자가 ASCII 영역을 벗어난 경우는 무시합니다.
        - 일단 Browser가 모든 키 입력을 Chrome에 넘기고, draw()를 호출하여 새 문자들이 실제로 표시되도록 합니다.
    - 마지막으로 일단 새 URL이 입력되면 Enter 키(handle_enter)를 처리하여 실제로 브라우저에 새 주소를 전달합니다.
